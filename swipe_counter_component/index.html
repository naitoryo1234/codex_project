<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>Swipe Counter</title>
    <script src="https://unpkg.com/streamlit-component-lib/dist/index.js"></script>
    <style>
      :root {
        color-scheme: light dark;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }
      body {
        margin: 0;
        padding: 0;
        background: transparent;
        color: inherit;
      }
      .counter-root {
        border: 1px solid rgba(60, 64, 67, 0.18);
        border-radius: 12px;
        padding: 12px 14px;
        background: rgba(248, 249, 251, 0.85);
        display: flex;
        flex-direction: column;
        gap: 10px;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.12);
      }
      @media (prefers-color-scheme: dark) {
        .counter-root {
          background: rgba(30, 32, 36, 0.8);
          border-color: rgba(120, 130, 140, 0.4);
          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.35);
        }
      }
      .counter-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 6px;
      }
      .counter-label {
        font-size: 0.95rem;
        font-weight: 600;
      }
      .counter-value {
        font-size: 1.6rem;
        font-weight: 700;
        font-variant-numeric: tabular-nums;
      }
      .counter-gesture {
        border: 1px dashed rgba(63, 81, 181, 0.5);
        border-radius: 10px;
        padding: 18px 12px;
        text-align: center;
        font-size: 0.9rem;
        color: rgba(33, 37, 41, 0.75);
        user-select: none;
        touch-action: none;
        background: rgba(63, 81, 181, 0.08);
        transition: background 120ms ease;
      }
      .counter-gesture.active {
        background: rgba(63, 81, 181, 0.18);
      }
      .counter-controls {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 8px;
        align-items: center;
      }
      .counter-controls button {
        appearance: none;
        border: none;
        border-radius: 10px;
        padding: 10px 0;
        font-size: 0.92rem;
        font-weight: 600;
        background: #2f80ed;
        color: #ffffff;
        cursor: pointer;
        transition: filter 120ms ease;
      }
      .counter-controls button:hover {
        filter: brightness(1.05);
      }
      .counter-controls button:active {
        filter: brightness(0.95);
      }
      .counter-controls .reset-btn {
        background: rgba(220, 53, 69, 0.85);
      }
      .counter-controls input[type="number"] {
        width: 100%;
        border: 1px solid rgba(60, 64, 67, 0.3);
        border-radius: 10px;
        padding: 9px 10px;
        font-size: 0.95rem;
        text-align: center;
        font-variant-numeric: tabular-nums;
      }
      .counter-caption {
        margin: 0;
        font-size: 0.8rem;
        color: rgba(80, 84, 92, 0.85);
        line-height: 1.4;
      }
    </style>
  </head>
  <body>
    <div class="counter-root">
      <div class="counter-header">
        <span class="counter-label" id="counter-label">小役回数</span>
        <span class="counter-value" id="counter-value">0</span>
      </div>
      <div class="counter-gesture" id="counter-gesture">
        上にスワイプで +1 / 下にスワイプで -1
      </div>
      <div class="counter-controls">
        <button type="button" data-delta="-1">-1</button>
        <input type="number" id="counter-input" min="0" step="1" inputmode="numeric" />
        <button type="button" data-delta="1">+1</button>
        <button type="button" data-action="reset" class="reset-btn">リセット</button>
      </div>
      <p class="counter-caption" id="counter-caption"></p>
    </div>
    <script>
      (function () {
        const valueEl = document.getElementById('counter-value');
        const gestureEl = document.getElementById('counter-gesture');
        const inputEl = document.getElementById('counter-input');
        const labelEl = document.getElementById('counter-label');
        const captionEl = document.getElementById('counter-caption');
        const buttons = Array.from(document.querySelectorAll('[data-delta]'));
        const resetBtn = document.querySelector('[data-action=reset]');

        const MIN_VALUE = 0;
        let storageKey = 'swipe_counter_storage';
        let value = 0;
        let pointerStartY = null;
        let hasHydrated = false;
        let updatingFromPython = false;

        function clamp(num) {
          if (!Number.isFinite(num)) return MIN_VALUE;
          return Math.max(MIN_VALUE, Math.round(num));
        }

        function render(newValue) {
          valueEl.textContent = newValue.toString();
          inputEl.value = newValue;
        }

        function persist(newValue) {
          const payload = { value: newValue, updatedAt: Date.now() };
          try {
            window.localStorage.setItem(storageKey, JSON.stringify(payload));
          } catch (error) {
            console.warn('swipe-counter: localStorage write failed', error);
          }
        }

        function syncToStreamlit(origin) {
          if (updatingFromPython) return;
          Streamlit.setComponentValue({ value, origin });
        }

        function apply(newValue, options) {
          const opts = Object.assign({ notify: true, persist: true, origin: 'user' }, options);
          value = clamp(newValue);
          render(value);
          if (opts.persist) {
            persist(value);
          }
          if (opts.notify) {
            syncToStreamlit(opts.origin);
          }
        }

        function adjust(delta) {
          if (!delta) return;
          apply(value + delta, { origin: 'adjust' });
        }

        function hydrateFromStorage() {
          if (hasHydrated) return false;
          hasHydrated = true;
          try {
            const stored = window.localStorage.getItem(storageKey);
            if (!stored) return false;
            const parsed = JSON.parse(stored);
            if (parsed && typeof parsed.value === 'number') {
              value = clamp(parsed.value);
              render(value);
              syncToStreamlit('storage');
              return true;
            }
          } catch (error) {
            console.warn('swipe-counter: localStorage read failed', error);
          }
          return false;
        }

        function onRender(event) {
          const detail = event.detail || {};
          const args = detail.args || {};
          const incomingValue = clamp(Number(args.value ?? value));
          storageKey = args.storage_key || storageKey;
          labelEl.textContent = args.label || '小役回数';
          captionEl.textContent = args.description || '上スワイプで+1 / 下スワイプで-1';

          const hydrated = hydrateFromStorage();

          if (!hydrated && incomingValue !== value) {
            updatingFromPython = true;
            apply(incomingValue, { notify: false, origin: 'python' });
            updatingFromPython = false;
          } else if (!hydrated) {
            render(value);
          } else if (incomingValue !== value) {
            updatingFromPython = true;
            apply(incomingValue, { notify: false, origin: 'python' });
            updatingFromPython = false;
          }

          Streamlit.setFrameHeight(document.body.scrollHeight);
        }

        gestureEl.addEventListener('pointerdown', (event) => {
          pointerStartY = event.clientY;
          gestureEl.setPointerCapture(event.pointerId);
          gestureEl.classList.add('active');
        });

        gestureEl.addEventListener('pointerup', (event) => {
          if (pointerStartY === null) return;
          const deltaY = event.clientY - pointerStartY;
          const threshold = 28;
          if (deltaY <= -threshold) {
            adjust(1);
          } else if (deltaY >= threshold) {
            adjust(-1);
          }
          pointerStartY = null;
          gestureEl.classList.remove('active');
          gestureEl.releasePointerCapture(event.pointerId);
        });

        gestureEl.addEventListener('pointercancel', () => {
          pointerStartY = null;
          gestureEl.classList.remove('active');
        });

        gestureEl.addEventListener('touchmove', (event) => {
          if (pointerStartY === null) return;
          event.preventDefault();
        }, { passive: false });

        buttons.forEach((btn) => {
          btn.addEventListener('click', () => {
            const delta = Number(btn.dataset.delta);
            adjust(delta);
          });
        });

        if (resetBtn) {
          resetBtn.addEventListener('click', () => {
            apply(MIN_VALUE, { origin: 'reset' });
          });
        }

        inputEl.addEventListener('change', () => {
          const parsed = clamp(Number(inputEl.value));
          apply(parsed, { origin: 'input' });
        });

        Streamlit.setComponentReady();
        Streamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender);
      })();
    </script>
  </body>
</html>
